Description: StorPool: implement clone_image().
 Change-Id: Idd3b79aa945a7210420a1fe57356a4dbad4f691f
Forwarded: not-needed
Author: Peter Penchev <openstack-dev@storpool.com>
Last-Update: 2022-06-01

--- a/cinder/volume/drivers/storpool.py
+++ b/cinder/volume/drivers/storpool.py
@@ -21,7 +21,9 @@
 from oslo_log import log as logging
 from oslo_utils import excutils
 from oslo_utils import importutils
+from oslo_utils import netutils
 from oslo_utils import units
+from oslo_utils import uuidutils
 import six
 
 from cinder import context
@@ -58,6 +60,28 @@
 CONF.register_opts(storpool_opts, group=configuration.SHARED_CONF_GROUP)
 
 
+def _extract_cinder_ids(urls):
+    ids = []
+    for url in urls:
+        # The url can also be None and a TypeError is raised
+        # TypeError: a bytes-like object is required, not 'str'
+        if not url:
+            continue
+        parts = netutils.urlsplit(url)
+        if parts.scheme == 'cinder':
+            if parts.path:
+                vol_id = parts.path.split('/')[-1]
+            else:
+                vol_id = parts.netloc
+            if uuidutils.is_uuid_like(vol_id):
+                ids.append(vol_id)
+            else:
+                LOG.debug("Ignoring malformed image location uri "
+                          "'%(url)s'", {'url': url})
+
+    return ids
+
+
 class StorPoolConfigurationInvalid(exception.CinderException):
     message = _("Invalid parameter %(param)s in the %(section)s section "
                 "of the /etc/storpool.conf file: %(error)s")
@@ -96,6 +120,7 @@
                   connector will handle this.
                 - Drop backup_volume()
                 - Avoid data duplication in create_cloned_volume()
+                - Implement clone_image()
     """
 
     VERSION = '2.0.0'
@@ -200,6 +225,43 @@
         except spapi.ApiError as e:
             raise self._backendException(e)
 
+    def clone_image(self, context, volume,
+                    image_location, image_meta, image_service):
+        if (image_meta.get('container_format') != 'bare' or
+                image_meta.get('disk_format') != 'raw'):
+            LOG.info("Requested image %(id)s is not in raw format.",
+                     {'id': image_meta.get('id')})
+            return None, False
+
+        LOG.debug('Check whether the image is accessible')
+        visibility = image_meta.get('visibility', None)
+        public = (
+            visibility and visibility == 'public' or
+            image_meta.get('is_public', False) or
+            image_meta['owner'] == volume['project_id']
+        )
+        if not public:
+            LOG.warning(
+                'The requested image is not accessible by the current tenant'
+            )
+            return None, False
+
+        LOG.debug('On to parsing %(loc)s', {'loc': repr(image_location)})
+        direct_url, locations = image_location
+        urls = list(set([direct_url] + [
+            loc.get('url') for loc in locations or []
+        ]))
+        image_volume_ids = _extract_cinder_ids(urls)
+        LOG.debug('image_volume_ids %(ids)s', {'ids': repr(image_volume_ids)})
+
+        if not image_volume_ids:
+            LOG.info('No Cinder volumes found to clone')
+            return None, False
+
+        vol_id = image_volume_ids[0]
+        LOG.info('Cloning volume %(vol_id)s', {'vol_id': vol_id})
+        return self.create_cloned_volume(volume, {'id': vol_id}), True
+
     def create_cloned_volume(self, volume, src_vref):
         refname = self._attach.volumeName(src_vref['id'])
         size = int(volume['size']) * units.Gi
